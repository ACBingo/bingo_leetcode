[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/description/)

题意好绕，看半天都没懂要干什么。
我直接上个图可能就能一眼看明白了：
![](https://images2018.cnblogs.com/blog/653667/201806/653667-20180626213851850-489464208.png)

总之，当明白题意后，直接就能想到暴力法枚举所有可能性，不过如果再画一下图基本就能发现：两线段之间形成的区域总是会受到其中较短那条长度的限制。
我举个例子，对于所有以(1,a1)为左边构成的矩阵，最大的一个肯定在右边(n,an)开始数，第一个大于等于ai的边，我们记成aj。即以a1为左边的最大矩阵肯定是  以right边从（j，aj）~（n，an）构成矩阵中的其中一个。实际上，对于（1，a1）~（j，aj）的边，我们就没有必要去算了。然后，以（2，a2）为左边，此时注意，如果a2小于等于a1，那么不必算了。如果a2>a1,那么此时与a1同理。依次类推。。（我想到的这个思路感觉好绕- -）

官方给出的双指针法好像更清晰易懂一些，贪心思想：
> 最初我们考虑由最外围两条线段构成的区域。现在，为了使面积最大化，我们需要考虑更长的两条线段之间的区域。如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。但是，在同样的条件下，移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。

```
class Solution {
public:
    int maxArea(vector<int> &height) {
        int maxarea = 0;
        int l = 0, r = height.size() - 1;
        while (l < r) {
            maxarea = max(maxarea, min(height[l], height[r]) * (r - l));
            if (height[l] < height[r]) {
                l++;
            } else {
                r--;
            }
        }

        return maxarea;
    }
};
```